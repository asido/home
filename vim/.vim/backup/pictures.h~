#ifndef PICTURES_B6I697QF
#define PICTURES_B6I697QF

#include <iostream>
#include <string>
#include <vector>

class Pic_base
{
	friend std::ostream& operator<<(std::ostream&, const Picture&);
	friend class Frame_Pic;
	friend class HCat_Pic;
	friend class VCat_Pic;
	friend class String_Pic;

	protected:
		static void pad(std::ostream& os, wd_sz beg, wd_sz end)
		{
			while(beg != end)
			{
				os << " ";
				++beg;
			}
		}

	private:
		typedef std::vector<std::string>::size_type ht_sz;
		typedef std::string::size_type wd_sz;

		// = 0 means that this is a pure virtual function.
		// the implementation is not in this class
		// and by that we promise never to have a concrete object of this class.
		// In other words, you say that this class is abstract
		virtual wd_sz width() const = 0;
		virtual ht_sz height const = 0;
		virtual void display(std::ostream&, ht_sz, bool) const = 0;
};

class Frame_Pic: public Pic_base
{
	friend Picture frame(const Picture&);

	private:
		Ptr<Pic_base> p;
		Frame_Pic(const Ptr<Pic_base>& pic): p(pic) {}

		wd_sz width() const { return p->width() + 4; }
		ht_sz height() const { return p->height() + 4; }
		void display(std::ostream&, gt_sz, bool) const;
};

class VCat_Pic: public Pic_base
{
	friend Picture vcat(const Picture&, const Picture&);

	private:
		Ptr<Pic_base> top, bottom;
		VCat_Pic(const Ptr<Pic_base>& t, const Ptr<Pic_base>& b):
			top(t), bottom(b) {}

		wd_sz width() const { return std::max(top->width(), bottim->width()); }
		ht_sz height() const { return top->height() + bottom->height(); }
		void display(std::ostream&, ht_sz, bool) const;
};

class HCat_Pic: public Pic_base
{
	friend Picture hcat(const Picture&, const Picture&);

	private:
		Ptr<Pic_base> left, right;
		HCat_Pic(const Ptr<Pic_base>& l, const Ptr<Pic_base>& r):
			left(l), right(r) {}

		wd_sz width() const { return left->width() + right->width(); }
		ht_sz height() const { return std::max(left->height(), right->height()); }
		void display(std::ostream&, ht_sz, bool) const;
};

class String_Pic: public Pic_base
{
	friend class Picture;

	private:
		std::vector<std::string> data;
		String_Pic(const std::vector<std::string>& v): data(v) {}

		wd_sz width() const;
		ht_sz height() const { return data.size(); }
		void display(std::ostream&, ht_sz, bool) const;
};


class Picture
{
	friend std::ostream& operator<<(std::ostream&, const Picture&);
	friend Picture frame(const Picture&);
	friend Picture hcat(const Picture&, const Picture&);
	friend Picture vcat(const Picture&, const Picture&);

	public:
		Picture(const std::vector<std::string>& = std::vector<std::string>());

	private:
		Picture(Pic_base* ptr): p(ptr) {}
		Ptr<Pic_base> p;
};

Picture frame(const Picture&);
Picture hcat(const Picture&, const Picture&);
Picture vcat(const Picture&, const Picture&);
std::ostream& operator<<(std::ostream&, const Picture&);

#endif /* end of include guard: PICTURES_B6I697QF */
